import 'package:mongo_dart/mongo_dart.dart';

/// @param {object} [options] Optional settings.
/// @param {(number|string)} [options.writeConcern] The write concern.
/// @param {boolean} [options.unique=false] Creates an unique index.
/// @param {boolean} [options.sparse=false] Creates a sparse index.
/// @param {boolean} [options.background=false] Creates the index in the background, yielding whenever possible.
/// @param {boolean} [options.dropDups=false] A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value
/// @param {number} [options.min] For geospatial indexes set the lower bound for the co-ordinates.
/// @param {number} [options.max] For geospatial indexes set the high bound for the co-ordinates.
/// @param {number} [options.v] Specify the format version of the indexes.
/// @param {number} [options.expireAfterSeconds] Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)
/// @param {string} [options.name] Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)
/// @param {object} [options.partialFilterExpression] Creates a partial index based on the given filter object (MongoDB 3.2 or higher)
/// @param {object} [options.collation] Specify collation (MongoDB 3.4 or higher) settings for update operation (see 3.4 documentation for available fields).
/// @param {ClientSession} [options.session] optional session to use for this operation
class CreateIndexOptions {
  DbCollection collection;
  WriteConcern? writeConcern;
  bool uniqueIndex;
  bool sparseIndex;
  bool background;
  bool dropDuplicatedEntries;
  double? geoLowerBound;
  double? geoHighBound;
  double? formatVersion;
  int? expireAfterSeconds;
  String? indexName;
  Map? partialFilterExpression;
  Map? collation;

  // Todo
  //ClientSession session;

  CreateIndexOptions(
    this.collection, {
    this.writeConcern,
    this.uniqueIndex = false,
    this.sparseIndex = false,
    this.background = false,
    this.dropDuplicatedEntries = false,
    this.geoLowerBound,
    this.geoHighBound,
    this.indexName,
    this.partialFilterExpression,
    this.collation,
    /* this.session*/
  });

  Map<String, Object> get options => <String, Object>{
        if (writeConcern != null)
          keyWriteConcern:
              writeConcern!.asMap(collection.db.masterConnection.serverStatus),
        keyUniqueIndex: uniqueIndex,
        keySparseIndex: sparseIndex,
        keyBackground: background,
        keyDropDuplicatedEntries: dropDuplicatedEntries,
        if (geoLowerBound != null) keyGeoLowerBound: geoLowerBound!,
        if (geoHighBound != null) keyGeoHighBound: geoHighBound!,
        if (formatVersion != null) keyFormatVersion: formatVersion!,
        if (expireAfterSeconds != null)
          keyExpireAfterSeconds: expireAfterSeconds!,
        if (indexName != null) keyIndexName: indexName!,
        if (partialFilterExpression != null)
          keyPartialFilterExpression: partialFilterExpression!,
        if (collation != null) keyCollation: collation!,
        //if (session 1= null) keySession: session
      };
}
